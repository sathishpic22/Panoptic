// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.24;
// Interfaces
import {PanopticPool} from "./PanopticPool.sol";
import {IRiskEngine} from "@contracts/interfaces/IRiskEngine.sol";
import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
// Inherited implementations
import {Clone} from "clones-with-immutable-args/Clone.sol";
import {ERC20Minimal} from "@tokens/ERC20Minimal.sol";
import {Multicall} from "@base/Multicall.sol";
// Libraries
import {Errors} from "@libraries/Errors.sol";
import {InteractionHelper} from "@libraries/InteractionHelper.sol";
import {Math} from "@libraries/Math.sol";
import {SafeTransferLib} from "@libraries/SafeTransferLib.sol";
// Custom types
import {Currency} from "v4-core/types/Currency.sol";
import {LeftRightSigned} from "@types/LeftRight.sol";
import {TokenId} from "@types/TokenId.sol";
import {RiskParameters} from "@types/RiskParameters.sol";
import {MarketState, MarketStateLibrary} from "@types/MarketState.sol";

/// @title Collateral Tracking System / Margin Accounting used in conjunction with a Panoptic Pool.
/// @author Axicon Labs Limited
//
/// @notice Tracks collateral of users which is key to ensure the correct level of collateralization is achieved.
/// This is represented as an ERC20 share token. A Panoptic pool has 2 tokens, each issued by its own instance of a CollateralTracker.
/// All math within this contract pertains to a single token.
//
/// @notice This contract uses the ERC4626 standard allowing the minting and burning of "shares" (represented using ERC20 inheritance) in exchange for underlying "assets".
/// Panoptic uses a collateral tracking system that is similar to TradFi margin accounts. While users can borrow and
/// effectively control funds several times larger than the collateral they deposited, they cannot withdraw those funds
/// from the Panoptic-Uniswap ecosystem. All funds are always owned by the Panoptic protocol, but users will:
//
/// @notice 1) collect any fees generated by selling an option.
//
/// @notice 2) get any gain in capital that results from buying an option that becomes in-the-money.
contract CollateralTracker is Clone, ERC20Minimal, Multicall {
    using Math for uint256;

    /*//////////////////////////////////////////////////////////////
                                EVENTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Emitted when assets are deposited into the Collateral Tracker.
    /// @param sender The address of the caller
    /// @param owner The address of the recipient of the newly minted shares
    /// @param assets The amount of assets deposited by `sender` in exchange for `shares`
    /// @param shares The amount of shares minted to `owner`
    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);

    /// @notice Emitted when assets are withdrawn from the Collateral Tracker.
    /// @param sender The address of the caller
    /// @param receiver The address of the recipient of the withdrawn assets
    /// @param owner The address of the owner of the shares being burned
    /// @param assets The amount of assets withdrawn to `receiver`
    /// @param shares The amount of shares burned by `owner` in exchange for `assets`
    event Withdraw(
        address indexed sender,
        address indexed receiver,
        address indexed owner,
        uint256 assets,
        uint256 shares
    );

    /// @notice Emitted when shares are donated to the protocol.
    /// @param sender The address of the caller
    /// @param shares The amount of shares burned by the sender
    event Donate(address indexed sender, uint256 shares);

    /// @notice Emitted when a commission is paid.
    /// @param owner The address of the owner of the shares being used to pay for the commission
    /// @param builder The address of the account that received the commission if a builderCode is provided
    /// @param commissionPaidProtocol The amount of assets paid that goes to the PLPs (if builder == address(0)) or to the protocol
    /// @param commissionPaidBuilder The amount of assets paid that goes to the builder
    event CommissionPaid(
        address indexed owner,
        address indexed builder,
        uint128 commissionPaidProtocol,
        uint128 commissionPaidBuilder
    );

    /// @notice Emitted when a user attempts to settle interest but lacks sufficient shares to pay in full.
    /// @dev The user's borrow index is not updated, meaning they will need to pay this interest again in the future.
    /// @param owner The address of the insolvent user
    /// @param interestOwed The total amount of interest the user owed
    /// @param interestPaid The actual amount of interest paid (value of shares burned)
    /// @param sharesBurned The number of shares burned in the partial payment
    event InsolvencyPenaltyApplied(
        address indexed owner,
        uint256 interestOwed,
        uint256 interestPaid,
        uint256 sharesBurned
    );

    /*//////////////////////////////////////////////////////////////
                               CONSTANTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Prefix for the token symbol (i.e. poUSDC).
    string internal constant TICKER_PREFIX = "po";

    /// @notice Prefix for the token name (i.e POPT-V1 USDC LP on ETH/USDC 30bps).
    string internal constant NAME_PREFIX = "POPT-V1";

    /// @notice Decimals for computation (1 bps (1 basis point) precision: 0.01%).
    /// @dev uint type for composability with unsigned integer based mathematical operations.
    uint256 internal constant DECIMALS = 10_000;

    /// @notice Decimals for WAD calculations.
    uint256 internal constant WAD = 1e18;

    /// @notice Mask zero the value between bits 112 and 150);
    uint256 internal constant TARGET_RATE_MASK =
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFC000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFF;

    bool internal constant IS_NOT_DEPOSIT = false;
    bool internal constant IS_DEPOSIT = true;

    /// @notice Transient storage slot for the utilization
    bytes32 internal constant UTILIZATION_TRANSIENT_SLOT =
        keccak256("panoptic.utilization.snapshot");

    /*//////////////////////////////////////////////////////////////
                           PANOPTIC POOL DATA
    //////////////////////////////////////////////////////////////*/

    /// @notice Cached amount of assets accounted to be held by the Panoptic Pool — ignores donations, pending fee payouts, and other untracked balance changes.
    uint128 internal s_depositedAssets;

    /// @notice Amount of assets moved from the Panoptic Pool to the AMM.
    uint128 internal s_assetsInAMM;

    /// @notice Amount of shares credited to the protocol, includes credits and purchased option liquidity above the rehypothecation threshold.
    uint256 internal s_creditedShares;

    /*//////////////////////////////////////////////////////////////
                           UNISWAP POOL DATA
    //////////////////////////////////////////////////////////////*/

    /// @notice Boolean which tracks whether this CollateralTracker has been initialized.
    bool internal s_initialized;

    /*//////////////////////////////////////////////////////////////
                   POOL-SPECIFIC IMMUTABLE PARAMETERS
    //////////////////////////////////////////////////////////////*/

    // The parameters will be encoded at `_getImmutableArgsOffset()` in calldata as follows:
    // abi.encodePacked(address panopticPool, bool underlyingIsToken0, address underlyingToken, address token0, address token1, uint24 poolFee)
    // bytes: 0                    20                 21                   41                   61                   81                   101                 121
    //        |<---- 160 bits ---->|<---- 8 bits ---->|<---- 160 bits ---->|<---- 160 bits ---->|<---- 160 bits ---->|<---- 160 bits ---->|<---- 160 bits ---->|<---- 24 bits ---->|
    //             panopticPool     underlyingIsToken0    underlyingToken          token0               token1             riskEngine           POOL_MANAGER          poolFee

    /// @notice Retrieve the Panoptic Pool that this collateral token belongs to.
    /// @return The Panoptic Pool associated with this collateral token
    function panopticPool() public pure returns (PanopticPool) {
        return PanopticPool(_getArgAddress(0));
    }

    /// @notice Retrieve a boolean indicating whether the underlying token is token0 or token1 in the Uniswap V3 pool.
    /// @return _underlyingIsToken0 True if the underlying token is token0, false if it is token1
    function underlyingIsToken0() public pure returns (bool _underlyingIsToken0) {
        uint256 offset = _getImmutableArgsOffset();

        assembly ("memory-safe") {
            _underlyingIsToken0 := shr(0xf8, calldataload(add(offset, 20)))
        }
    }

    /// @notice Retrieve the address of the underlying token.
    /// @return The address of the underlying token
    function underlyingToken() public pure returns (address) {
        return _getArgAddress(21);
    }

    /// @notice Retrieve the address of token0 in the Uniswap V3 pool.
    /// @return The address of token0 in the Uniswap V3 pool
    function token0() public pure returns (address) {
        return _getArgAddress(41);
    }

    /// @notice Retrieve the address of token1 in the Uniswap V3 pool.
    /// @return The address of token1 in the Uniswap V3 pool
    function token1() public pure returns (address) {
        return _getArgAddress(61);
    }

    /// @notice Retrieve the RiskEngine associated with that CollateralTracker.
    /// @return The RiskEngine instance associated with that CollateralTracker's uniswap pool
    function riskEngine() public pure returns (IRiskEngine) {
        return IRiskEngine(_getArgAddress(81));
    }

    /// @notice Retrieve the PoolManager associated with that CollateralTracker.
    /// @dev stored as zero if not a Uniswap v4 pool
    /// @return The PoolManager instance associated with that CollateralTracker's uniswap V4 pool
    function poolManager() public pure returns (IPoolManager) {
        return IPoolManager(_getArgAddress(101));
    }

    /// @notice Retrieve the fee of the Uniswap V3 pool.
    /// @return _poolFee The fee of the Uniswap V3 pool
    function poolFee() public pure returns (uint24 _poolFee) {
        uint256 offset = _getImmutableArgsOffset();

        assembly ("memory-safe") {
            _poolFee := shr(0xe8, calldataload(add(offset, 121)))
        }
    }

    /*//////////////////////////////////////////////////////////////
                                STORAGE
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice How the Borrow Index Works
     *
     * The borrow index is a global accumulator that tracks how much $1 of debt
     * grows over time with compound interest. It starts at 1e18 (representing 1.0)
     * and increases continuously.
     *
     * Example:
     * - User borrows 100 tokens when globalIndex = 1.0e18
     * - Time passes, globalIndex grows to 1.2e18 (20% growth)
     * - User now owes: 100 * (1.2e18 / 1.0e18) = 120 tokens
     *
     * Each user stores their "checkpoint" index from their last interaction,
     * allowing efficient compound interest calculation without iteration.
     */

    /// @notice Global interest rate accumulator packed into a single 256-bit value
    /// @dev Layout:
    ///      - Left slot (106 bits): Accumulated unrealized interest that hasn't been distributed (max deposit is 2**104)
    ///      - Next 38 bits: the rateAtTarget value in WAD (2**38 = 800% interest rate)
    ///      - Next lowest 32 bits: Last interaction epoch (1 epoch = block.timestamp/4)
    ///      - Lowest 80 bits: Global borrow index in WAD (starts at 1e18). 2**80 = 1.75 years at 800% interest
    ///      The borrow index tracks the compound growth factor since protocol inception.
    ///      A user's current debt = originalDebt * (currentBorrowIndex / userBorrowIndexSnapshot)
    MarketState internal s_marketState;

    /// @notice Tracks each user's borrowing state and last interaction checkpoint
    /// @dev Packed layout:
    ///      - Left slot (128 bits): Net borrows = netShorts - netLongs
    ///        Represents the user's net borrowed amount in tokens
    ///        Can be negative, in which case they purchased more options than they sold
    ///      - Right slot (128 bits): User's borrow index snapshot
    ///        The global borrow index value when this user last accrued interest
    /// @dev Interest calculation: interestOwed = netBorrows * (currentIndex - userIndex) / userIndex
    mapping(address account => LeftRightSigned interestState) internal s_interestState;

    /*//////////////////////////////////////////////////////////////
                            RISK PARAMETERS
    //////////////////////////////////////////////////////////////*/

    /// @notice The commission fee, in basis points, collected from PLPs at option mint.
    /// @dev In Panoptic, options never expire, commissions are only paid when a new position is minted.
    /// @dev We believe that this will eliminate the impact of the commission fee on the user's decision-making process when closing a position.
    uint256 immutable COMMISSION_FEE;

    /*//////////////////////////////////////////////////////////////
                            ACCESS CONTROL
    //////////////////////////////////////////////////////////////*/

    /// @notice Reverts if the associated Panoptic Pool is not the caller.
    modifier onlyPanopticPool() {
        _onlyPanopticPool();
        _;
    }

    function _onlyPanopticPool() internal view {
        if (msg.sender != address(panopticPool())) revert Errors.NotPanopticPool();
    }

    /*//////////////////////////////////////////////////////////////
                  INITIALIZATION & PARAMETER SETTINGS
    //////////////////////////////////////////////////////////////*/

    /// @notice Set immutable parameters for the Collateral Tracker.
    /// @param _commissionFee The commission fee, in basis points, collected from PLPs at option mint
    constructor(uint256 _commissionFee) {
        COMMISSION_FEE = _commissionFee;
    }

    /// @notice Initializes a new `CollateralTracker` instance with 1 virtual asset and 10^6 virtual shares. Can only be called once; reverts if already initialized.
    function initialize() external {
        // fails if already initialized
        if (s_initialized) revert Errors.CollateralTokenAlreadyInitialized();
        s_initialized = true;

        // these virtual shares function as a multiplier for the capital requirement to manipulate the pool price
        // e.g. if the virtual shares are 10**6, then the capital requirement to manipulate the price to 10**12 is 10**18
        _internalSupply = 10 ** 6;

        // set total assets to 1
        // the initial share price is defined by 1/virtualShares
        s_depositedAssets = 1;

        // store the initial block and initialize the borrowIndex
        s_marketState = MarketStateLibrary.storeMarketState(WAD, block.timestamp >> 2, 0, 0);
    }

    /*//////////////////////////////////////////////////////////////
                      COLLATERAL TOKEN INFORMATION
    //////////////////////////////////////////////////////////////*/

    /// @notice Get information about the utilization of this collateral vault.
    /// @return depositedAssets Cached amount of assets accounted to be held by the Panoptic Pool — ignores donations, pending fee payouts, and other untracked balance changes
    /// @return insideAMM The underlying token amount held in the AMM
    /// @return creditedShares The amount of shares currently held as credit
    /// @return currentPoolUtilization The pool utilization defined as`s_assetsInAMM * 10_000 / totalAssets()`,
    /// where totalAssets is the total tracked assets in the AMM and PanopticPool minus fees and donations to the Panoptic pool
    function getPoolData()
        external
        view
        returns (
            uint256 depositedAssets,
            uint256 insideAMM,
            uint256 creditedShares,
            uint256 currentPoolUtilization
        )
    {
        depositedAssets = s_depositedAssets;
        insideAMM = s_assetsInAMM;
        creditedShares = s_creditedShares;
        currentPoolUtilization = _poolUtilizationView();
    }

    /// @notice Returns the global borrow index that tracks compound interest growth
    /// @dev The index starts at 1e18 and compounds continuously. Represents how much 1 unit of debt has grown since inception
    /// @return The current global borrow index in WAD (18 decimals)
    function borrowIndex() external view returns (uint80) {
        return s_marketState.borrowIndex();
    }

    /// @notice Returns the last time at which interest rates were compounded.
    /// @return The last time at which the interest rates were compounded
    function lastInteractionTimestamp() external view returns (uint256) {
        return s_marketState.marketEpoch() << 2;
    }

    /// @notice Returns the accumulated unrealized global interest
    /// @return The total interest that has accumulated but not yet been distributed to lenders
    function unrealizedGlobalInterest() external view returns (uint256) {
        return s_marketState.unrealizedInterest();
    }

    /// @notice Returns rateAtTarget of the market
    /// @return The rateAtTarget
    function rateAtTarget() external view returns (uint256) {
        return s_marketState.rateAtTarget();
    }

    /// @notice Returns the borrowing state for a specific user
    /// @dev Returns both the user's borrow index snapshot and their net borrowed amount
    /// @return userBorrowIndex The borrow index when the user last accrued interest (used as the basis for interest calculation)
    /// @return netBorrows The net borrowed amount for the user (positive = borrower, zero/negative = no interest owed)
    function interestState(
        address user
    ) external view returns (int128 userBorrowIndex, int128 netBorrows) {
        return (s_interestState[user].rightSlot(), s_interestState[user].leftSlot());
    }

    /// @notice Returns name of token composed of underlying token symbol and pool data.
    /// @return The name of the token
    function name() external view returns (string memory) {
        // this logic requires multiple external calls and error handling, so we do it in a delegatecall to a library to save bytecode size
        return
            InteractionHelper.computeName(
                token0(),
                token1(),
                underlyingIsToken0(),
                poolFee(),
                NAME_PREFIX
            );
    }

    /// @notice Returns symbol as prefixed symbol of underlying token.
    /// @return The symbol of the token
    function symbol() external view returns (string memory) {
        // this logic requires multiple external calls and error handling, so we do it in a delegatecall to a library to save bytecode size
        return InteractionHelper.computeSymbol(underlyingToken(), TICKER_PREFIX);
    }

    /// @notice Returns decimals of underlying token (0 if not present).
    /// @return The decimals of the token
    function decimals() external view returns (uint8) {
        // this logic requires multiple external calls and error handling, so we do it in a delegatecall to a library to save bytecode size
        return InteractionHelper.computeDecimals(underlyingToken());
    }

    /*//////////////////////////////////////////////////////////////
                     LIMITED TRANSFER FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /// @dev See {IERC20-transfer}.
    /// @dev Requirements:
    /// - the caller must have a balance of at least `amount`.
    /// - the caller must not have any open positions on the Panoptic Pool.
    function transfer(
        address recipient,
        uint256 amount
    ) public override(ERC20Minimal) returns (bool) {
        _accrueInterest(msg.sender, IS_NOT_DEPOSIT);
        // make sure the caller does not have any open option positions
        // if they do: we don't want them sending panoptic pool shares to others
        // as this would reduce their amount of collateral against the opened positions

        if (panopticPool().numberOfLegs(msg.sender) != 0) revert Errors.PositionCountNotZero();

        return ERC20Minimal.transfer(recipient, amount);
    }

    /// @dev See {IERC20-transferFrom}.
    /// @dev Requirements:
    /// - the `from` must have a balance of at least `amount`.
    /// - the caller must have allowance for `from` of at least `amount` tokens.
    /// - `from` must not have any open positions on the Panoptic Pool.
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public override(ERC20Minimal) returns (bool) {
        _accrueInterest(from, IS_NOT_DEPOSIT);
        // make sure the sender does not have any open option positions
        // if they do: we don't want them sending panoptic pool shares to others
        // as this would reduce their amount of collateral against the opened positions

        if (panopticPool().numberOfLegs(from) != 0) revert Errors.PositionCountNotZero();

        return ERC20Minimal.transferFrom(from, to, amount);
    }

    /*//////////////////////////////////////////////////////////////
                        UNISWAP V4 LOCK CALLBACK
    //////////////////////////////////////////////////////////////*/

    /// @notice Initiates the unlock callback to wrap/unwrap `delta` amount of the underlying asset and transfer to/from the Panoptic Pool.
    /// @param account The address of the account to transfer the underlying asset to/from
    /// @param delta The amount of the underlying asset to wrap/unwrap and transfer
    function _settleCurrencyDelta(address account, int256 delta) internal {
        poolManager().unlock(abi.encode(account, delta, msg.value));
    }

    /// @notice Uniswap V4 unlock callback implementation.
    /// @dev Parameters are `(address account, int256 delta, uint256 valueOrigin)`.
    /// @dev Wraps/unwraps `delta` amount of the underlying asset and transfers to/from the Panoptic Pool.
    /// @param data The encoded data containing the account, delta, and valueOrigin
    /// @return This function returns no data
    function unlockCallback(bytes calldata data) external returns (bytes memory) {
        if (msg.sender != address(poolManager())) revert Errors.UnauthorizedUniswapCallback();

        (address account, int256 delta, uint256 valueOrigin) = abi.decode(
            data,
            (address, int256, uint256)
        );

        address underlyingAsset = underlyingToken();
        if (delta > 0) {
            if (Currency.wrap(underlyingAsset).isAddressZero()) {
                poolManager().settle{value: uint256(delta)}();

                // keep checked to prevent underflows
                uint256 surplus = valueOrigin - uint256(delta);
                if (surplus > 0) SafeTransferLib.safeTransferETH(account, surplus);
            } else {
                poolManager().sync(Currency.wrap(underlyingAsset));
                SafeTransferLib.safeTransferFrom(
                    underlyingAsset,
                    account,
                    address(poolManager()),
                    uint256(delta)
                );
                poolManager().settle();
            }

            poolManager().mint(address(panopticPool()), uint160(underlyingAsset), uint256(delta));
        } else if (delta < 0) {
            unchecked {
                delta = -delta;
            }
            poolManager().burn(address(panopticPool()), uint160(underlyingAsset), uint256(delta));
            poolManager().take(Currency.wrap(underlyingAsset), account, uint256(delta));
        }

        return "";
    }

    /*//////////////////////////////////////////////////////////////
                     STANDARD ERC4626 INTERFACE
    //////////////////////////////////////////////////////////////*/

    /// @notice Get the token contract address of the underlying asset being managed.
    /// @return assetTokenAddress The address of the underlying asset
    function asset() external pure returns (address assetTokenAddress) {
        return underlyingToken();
    }

    /// @notice Get the total amount of assets managed by the CollateralTracker vault.
    /// @dev This returns the total tracked assets in the AMM and PanopticPool,
    /// @dev - EXCLUDING the amount of collected fees (because they are reserved for short options)
    /// @dev - EXCLUDING any donations that have been made to the pool
    /// @return The total amount of assets managed by the CollateralTracker vault
    function totalAssets() public view returns (uint256) {
        unchecked {
            return uint256(s_depositedAssets) + s_assetsInAMM + s_marketState.unrealizedInterest();
        }
    }

    /// @notice Returns the total supply of shares including credited shares
    /// @return The total supply of shares (internal supply + credited shares)
    function totalSupply() public view returns (uint256) {
        unchecked {
            return _internalSupply + s_creditedShares;
        }
    }

    /// @notice Returns the amount of shares that can be minted for the given amount of assets.
    /// @param assets The amount of assets to be deposited
    /// @return shares The amount of shares that can be minted
    function convertToShares(uint256 assets) public view returns (uint256 shares) {
        return Math.mulDiv(assets, totalSupply(), totalAssets());
    }

    /// @notice Returns the amount of assets that can be redeemed for the given amount of shares.
    /// @param shares The amount of shares to be redeemed
    /// @return assets The amount of assets that can be redeemed
    function convertToAssets(uint256 shares) public view returns (uint256 assets) {
        return Math.mulDiv(shares, totalAssets(), totalSupply());
    }

    /// @notice Returns the amount of assets that can be redeem by the user.
    /// @param owner The redeeming address
    /// @return assets The amount of assets that can be redeemed
    function assetsOf(address owner) external view returns (uint256 assets) {
        return convertToAssets(balanceOf[owner]);
    }

    /// @notice Returns the maximum deposit amount.
    /// @return maxAssets The maximum amount of assets that can be deposited
    function maxDeposit(address) external pure returns (uint256 maxAssets) {
        return type(uint104).max;
    }

    /// @notice Returns shares received for depositing given amount of assets.
    /// @param assets The amount of assets to be deposited
    /// @return shares The amount of shares that can be minted
    function previewDeposit(uint256 assets) public view returns (uint256 shares) {
        shares = Math.mulDiv(assets, totalSupply(), totalAssets());
    }

    /// @notice Deposit underlying tokens (assets) to the Panoptic pool from the LP and mint corresponding amount of shares.
    /// @dev There is a maximum asset deposit limit of `2^104 - 1`.
    /// @dev Shares are minted and sent to the LP (`receiver`).
    /// @param assets Amount of assets deposited
    /// @param receiver User to receive the shares
    /// @return shares The amount of Panoptic pool shares that were minted to the recipient
    function deposit(uint256 assets, address receiver) external payable returns (uint256 shares) {
        _accrueInterest(msg.sender, IS_DEPOSIT);
        if (assets > type(uint104).max) revert Errors.DepositTooLarge();
        if (assets == 0) revert Errors.BelowMinimumRedemption();

        shares = previewDeposit(assets);

        address _poolManager = address(poolManager());

        if (_poolManager == address(0)) {
            // transfer assets (underlying token funds) from the user/the LP to the PanopticPool
            // in return for the shares to be minted
            SafeTransferLib.safeTransferFrom(
                underlyingToken(),
                msg.sender,
                address(panopticPool()),
                assets
            );
        }
        // mint collateral shares of the Panoptic Pool funds (this ERC20 token)
        _mint(receiver, shares);

        // update tracked asset balance
        s_depositedAssets += uint128(assets);

        if (_poolManager != address(0)) {
            // transfer assets from the user/the LP to the PanopticPool
            // in return for the shares to be minted
            _settleCurrencyDelta(msg.sender, int256(assets));
        }
        emit Deposit(msg.sender, receiver, assets, shares);
    }

    /// @notice Returns the maximum shares received for a deposit.
    /// @return maxShares The maximum amount of shares that can be minted
    function maxMint(address) external view returns (uint256 maxShares) {
        return convertToShares(type(uint104).max);
    }

    /// @notice Returns the amount of assets that would be deposited to mint a given amount of shares.
    /// @param shares The amount of shares to be minted
    /// @return assets The amount of assets required to mint `shares`
    function previewMint(uint256 shares) public view returns (uint256 assets) {
        // round up depositing assets to avoid protocol loss
        // This prevents minting of shares where the assets provided is rounded down to zero
        assets = Math.mulDivRoundingUp(shares, totalAssets(), totalSupply());
    }

    /// @notice Deposit required amount of assets to receive specified amount of shares.
    /// @dev There is a maximum asset deposit limit of `2^104 - 1`.
    /// @dev Shares are minted and sent to the LP (`receiver`).
    /// @param shares Amount of shares to be minted
    /// @param receiver User to receive the shares
    /// @return assets The amount of assets deposited to mint the desired amount of shares
    function mint(uint256 shares, address receiver) external payable returns (uint256 assets) {
        _accrueInterest(msg.sender, IS_DEPOSIT);
        assets = previewMint(shares);

        if (assets > type(uint104).max) revert Errors.DepositTooLarge();
        if (assets == 0) revert Errors.BelowMinimumRedemption();

        address _poolManager = address(poolManager());

        if (_poolManager == address(0)) {
            // transfer assets (underlying token funds) from the user/the LP to the PanopticPool
            // in return for the shares to be minted
            SafeTransferLib.safeTransferFrom(
                underlyingToken(),
                msg.sender,
                address(panopticPool()),
                assets
            );
        }

        // mint collateral shares of the Panoptic Pool funds (this ERC20 token)
        _mint(receiver, shares);

        // update tracked asset balance
        s_depositedAssets += uint128(assets);

        if (_poolManager != address(0)) {
            // transfer assets from the user/the LP to the PanopticPool
            // in return for the shares to be minted
            _settleCurrencyDelta(msg.sender, int256(assets));
        }

        emit Deposit(msg.sender, receiver, assets, shares);
    }

    /// @notice Returns The maximum amount of assets that can be withdrawn for a given user.
    /// If the user has any open positions, the max withdrawable balance is zero.
    /// @dev Calculated from the balance of the user; limited by the assets the pool has available.
    /// @param owner The address being withdrawn for
    /// @return maxAssets The maximum amount of assets that can be withdrawn
    function maxWithdraw(address owner) public view returns (uint256 maxAssets) {
        uint256 depositedAssets = s_depositedAssets;
        unchecked {
            uint256 available = depositedAssets > 0 ? depositedAssets - 1 : 0;
            uint256 balance = convertToAssets(balanceOf[owner]);
            return panopticPool().numberOfLegs(owner) == 0 ? Math.min(available, balance) : 0;
        }
    }

    /// @notice Returns The maximum amount of assets that can be withdrawn for a given user with open positions.
    /// If the user has any open positions, the max withdrawable balance is zero.
    /// @dev Calculated from the balance of the user; limited by the assets the pool has available.
    /// @param owner The address being withdrawn for
    /// @return maxAssets The maximum amount of assets that can be withdrawn
    function _maxWithdrawWithPositions(address owner) internal view returns (uint256 maxAssets) {
        uint256 depositedAssets = s_depositedAssets;
        unchecked {
            uint256 available = depositedAssets > 0 ? depositedAssets - 1 : 0;
            uint256 balance = convertToAssets(balanceOf[owner]);
            return Math.min(available, balance);
        }
    }

    /// @notice Returns the amount of shares that would be burned to withdraw a given amount of assets.
    /// @param assets The amount of assets to be withdrawn
    /// @return shares The amount of shares that would be burned
    function previewWithdraw(uint256 assets) public view returns (uint256 shares) {
        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply() is non-zero.

        return Math.mulDivRoundingUp(assets, supply, totalAssets());
    }

    /// @notice Redeem the amount of shares required to withdraw the specified amount of assets.
    /// @dev We can only use this standard 4626 function if the user has no open positions.
    /// @dev Shares are burned and assets are sent to the LP (`receiver`).
    /// @param assets Amount of assets to be withdrawn
    /// @param receiver User to receive the assets
    /// @param owner User to burn the shares from
    /// @return shares The amount of shares burned to withdraw the desired amount of assets
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) external returns (uint256 shares) {
        _accrueInterest(owner, IS_NOT_DEPOSIT);
        if (assets > maxWithdraw(owner)) revert Errors.ExceedsMaximumRedemption();
        if (assets == 0) revert Errors.BelowMinimumRedemption();

        shares = previewWithdraw(assets);

        // check/update allowance for approved withdraw
        if (msg.sender != owner) {
            uint256 allowed = allowance[owner][msg.sender];

            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares; // Saves gas for unlimited approvals.
        }

        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
        _burn(owner, shares);

        // update tracked asset balance
        // keep checked to prevent underflows
        s_depositedAssets -= uint128(assets);

        address _poolManager = address(poolManager());

        if (_poolManager == address(0)) {
            // transfer assets (underlying token funds) from the PanopticPool to the LP
            SafeTransferLib.safeTransferFrom(
                underlyingToken(),
                address(panopticPool()),
                receiver,
                assets
            );
        } else {
            // transfer assets from the PanopticPool to the LP
            unchecked {
                _settleCurrencyDelta(receiver, -int256(assets));
            }
        }

        emit Withdraw(msg.sender, receiver, owner, assets, shares);
    }

    /// @notice Redeem the amount of shares required to withdraw the specified amount of assets.
    /// @dev Reverts if the account is not solvent with the given `positionIdList`.
    /// @dev Shares are burned and assets are sent to the LP (`receiver`).
    /// @param assets Amount of assets to be withdrawn
    /// @param receiver User to receive the assets
    /// @param owner User to burn the shares from
    /// @param positionIdList The list of all option positions held by `owner`
    /// @param usePremiaAsCollateral Whether to compute accumulated premia for all legs held by the user for collateral (true), or just owed premia for long legs (false)
    /// @return shares The amount of shares burned to withdraw the desired amount of assets
    function withdraw(
        uint256 assets,
        address receiver,
        address owner,
        TokenId[] calldata positionIdList,
        bool usePremiaAsCollateral
    ) external returns (uint256 shares) {
        _accrueInterest(owner, IS_NOT_DEPOSIT);
        if (assets == 0) revert Errors.BelowMinimumRedemption();
        if (assets > _maxWithdrawWithPositions(owner)) revert Errors.ExceedsMaximumRedemption();

        shares = previewWithdraw(assets);

        // check/update allowance for approved withdraw
        if (msg.sender != owner) {
            uint256 allowed = allowance[owner][msg.sender];
            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares; // Saves gas for unlimited approvals.
        }

        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
        _burn(owner, shares);

        // update tracked asset balance
        s_depositedAssets -= uint128(assets);

        // reverts if account is not solvent/eligible to withdraw
        panopticPool().validateCollateralWithdrawable(owner, positionIdList, usePremiaAsCollateral);

        address _poolManager = address(poolManager());

        if (_poolManager == address(0)) {
            // transfer assets (underlying token funds) from the PanopticPool to the LP
            SafeTransferLib.safeTransferFrom(
                underlyingToken(),
                address(panopticPool()),
                receiver,
                assets
            );
        } else {
            // transfer assets from the PanopticPool to the LP
            unchecked {
                _settleCurrencyDelta(receiver, -int256(assets));
            }
        }
        emit Withdraw(msg.sender, receiver, owner, assets, shares);
    }

    /// @notice Returns the maximum amount of shares that can be redeemed for a given user.
    /// @dev If the user has any open positions, the max redeemable balance is zero.
    /// @param owner The redeeming address
    /// @return maxShares The maximum amount of shares that can be redeemed by `owner`
    function maxRedeem(address owner) public view returns (uint256 maxShares) {
        uint256 depositedAssets = s_depositedAssets;
        unchecked {
            uint256 available = convertToShares(depositedAssets > 0 ? depositedAssets - 1 : 0);
            uint256 balance = balanceOf[owner];
            return panopticPool().numberOfLegs(owner) == 0 ? Math.min(available, balance) : 0;
        }
    }

    /// @notice Returns the amount of assets resulting from a given amount of shares being redeemed.
    /// @param shares The amount of shares to be redeemed
    /// @return assets The amount of assets resulting from the redemption
    function previewRedeem(uint256 shares) public view returns (uint256 assets) {
        return convertToAssets(shares);
    }

    /// @notice Redeem exact shares for underlying assets.
    /// @dev We can only use this standard 4626 function if the user has no open positions.
    /// @param shares Amount of shares to be redeemed
    /// @param receiver User to receive the assets
    /// @param owner User to burn the shares from
    /// @return assets The amount of assets resulting from the redemption
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) external returns (uint256 assets) {
        _accrueInterest(owner, IS_NOT_DEPOSIT);
        if (shares > maxRedeem(owner)) revert Errors.ExceedsMaximumRedemption();

        // check/update allowance for approved redeem
        if (msg.sender != owner) {
            uint256 allowed = allowance[owner][msg.sender];

            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares; // Saves gas for unlimited approvals.
        }

        assets = previewRedeem(shares);
        if (assets == 0) revert Errors.BelowMinimumRedemption();

        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
        _burn(owner, shares);

        // update tracked asset balance
        // keep checked to avoid underflows
        s_depositedAssets -= uint128(assets);
        address _poolManager = address(poolManager());

        if (_poolManager == address(0)) {
            // transfer assets (underlying token funds) from the PanopticPool to the LP
            SafeTransferLib.safeTransferFrom(
                underlyingToken(),
                address(panopticPool()),
                receiver,
                assets
            );
        } else {
            // transfer assets from the PanopticPool to the LP
            unchecked {
                _settleCurrencyDelta(receiver, -int256(assets));
            }
        }
        emit Withdraw(msg.sender, receiver, owner, assets, shares);
    }

    /// @notice Donate exact shares to all shareholders.
    /// @dev Can only be used when the user has no open positions
    /// @param shares Amount of shares to be donated
    function donate(uint256 shares) external {
        _accrueInterest(msg.sender, IS_NOT_DEPOSIT);

        if (shares > maxRedeem(msg.sender)) revert Errors.ExceedsMaximumRedemption();

        uint256 assets = previewRedeem(shares);
        if (assets == 0) revert Errors.BelowMinimumRedemption();

        // burn collateral shares of the Panoptic Pool funds (this ERC20 token)
        _burn(msg.sender, shares);

        emit Donate(msg.sender, shares);
    }

    /// @notice Accrues protocol-wide interest for the calling user
    /// @dev Updates global interest state and settles any outstanding interest for msg.sender
    function accrueInterest() external {
        _accrueInterest(msg.sender, IS_NOT_DEPOSIT);
    }

    /// @notice Accrues protocol-wide interest and settles a specific user's interest.
    /// @dev This function should be called before any user action that affects their borrow balance.
    /// @param owner the account which calls accrue interest
    function _accrueInterest(address owner, bool isDeposit) internal {
        uint128 _assetsInAMM = s_assetsInAMM;
        (
            uint128 currentBorrowIndex,
            uint128 _unrealizedGlobalInterest,
            uint256 currentEpoch
        ) = _calculateCurrentInterestState(_assetsInAMM, _updateInterestRate());

        // USER
        LeftRightSigned userState = s_interestState[owner];
        int128 netBorrows = userState.leftSlot();
        int128 userBorrowIndex = int128(currentBorrowIndex);
        if (netBorrows > 0) {
            uint128 userInterestOwed = _getUserInterest(userState, currentBorrowIndex);
            if (userInterestOwed != 0) {
                uint256 _totalAssets;
                unchecked {
                    _totalAssets = s_depositedAssets + _assetsInAMM + _unrealizedGlobalInterest;
                }

                uint256 shares = Math.mulDivRoundingUp(
                    userInterestOwed,
                    totalSupply(),
                    _totalAssets
                );

                uint128 burntInterestValue = userInterestOwed;

                address _owner = owner;
                uint256 userBalance = balanceOf[_owner];
                if (shares > userBalance) {
                    if (!isDeposit) {
                        // update the accrual of interest paid
                        burntInterestValue = Math
                            .mulDiv(userBalance, _totalAssets, totalSupply())
                            .toUint128();

                        emit InsolvencyPenaltyApplied(
                            owner,
                            userInterestOwed,
                            burntInterestValue,
                            userBalance
                        );

                        /// Insolvent case: Pay what you can
                        _burn(_owner, userBalance);

                        /// @dev DO NOT update index. By keeping the user's old baseIndex, their debt continues to compound correctly from the original point in time.
                        userBorrowIndex = userState.rightSlot();
                    } else {
                        // set interest paid to zero
                        burntInterestValue = 0;

                        // we effectively **did not settle** this user:
                        // we keep their old baseIndex so future interest is computed correctly.
                        userBorrowIndex = userState.rightSlot();
                    }
                } else {
                    // Solvent case: Pay in full.
                    _burn(_owner, shares);
                }

                // Due to repeated rounding up when:
                //  - compounding the global borrow index (multiplicative propagation of rounding error), and
                //  - converting a user's interest into shares,
                // burntInterestValue can exceed _unrealizedGlobalInterest by a few wei (because that accumulator calculates interest additively).
                // In that case, treat all remaining unrealized interest as consumed
                // and clamp the bucket to zero; otherwise subtract normally.
                if (burntInterestValue > _unrealizedGlobalInterest) {
                    _unrealizedGlobalInterest = 0;
                } else {
                    unchecked {
                        // can never underflow because burntInterestValue <= _unrealizedGlobalInterest
                        _unrealizedGlobalInterest = _unrealizedGlobalInterest - burntInterestValue;
                    }
                }
            }
        }

        s_interestState[owner] = LeftRightSigned
            .wrap(0)
            .addToRightSlot(userBorrowIndex)
            .addToLeftSlot(netBorrows);

        s_marketState = MarketStateLibrary.storeMarketState(
            currentBorrowIndex,
            currentEpoch,
            s_marketState.rateAtTarget(),
            _unrealizedGlobalInterest
        );
    }

    /// @notice Calculates the current interest state without modifying storage
    /// @dev Simulates interest accrual from last interaction to current epoch
    /// @param _assetsInAMM Amount of assets currently deployed in AMM positions
    /// @param interestRateSnapshot The current interest rate to evaluate at
    /// @return currentBorrowIndex Updated global borrow index after simulated accrual
    /// @return _unrealizedGlobalInterest Total unrealized interest including new accrual
    /// @return currentEpoch Current epoch = block timestamp / 4
    function _calculateCurrentInterestState(
        uint128 _assetsInAMM,
        uint128 interestRateSnapshot
    )
        internal
        view
        returns (
            uint128 currentBorrowIndex,
            uint128 _unrealizedGlobalInterest,
            uint256 currentEpoch
        )
    {
        MarketState accumulator = s_marketState;

        currentEpoch = block.timestamp >> 2;
        uint256 previousEpoch = accumulator.marketEpoch();
        uint128 deltaTime;
        unchecked {
            deltaTime = uint32(currentEpoch - previousEpoch) << 2;
        }
        currentBorrowIndex = accumulator.borrowIndex();
        _unrealizedGlobalInterest = accumulator.unrealizedInterest();
        if (deltaTime > 0) {
            // Calculate interest growth
            uint128 rawInterest = (Math.wTaylorCompounded(interestRateSnapshot, uint128(deltaTime)))
                .toUint128();
            // Calculate interest owed on borrowed amount

            uint128 interestOwed = Math.mulDivWadRoundingUp(_assetsInAMM, rawInterest).toUint128();

            // keep checked to prevent overflows
            _unrealizedGlobalInterest += interestOwed;

            // Update borrow index
            unchecked {
                uint128 _borrowIndex = (WAD + rawInterest).toUint128();
                currentBorrowIndex = Math
                    .mulDivWadRoundingUp(currentBorrowIndex, _borrowIndex)
                    .toUint128();
            }
        }
    }

    /*//////////////////////////////////////////////////////////////
                  ADAPTIVE INTEREST RATE MODEL
    //////////////////////////////////////////////////////////////*/

    function _interestRateView(uint256 utilization) internal view returns (uint128) {
        uint128 avgRate = riskEngine().interestRate(utilization, s_marketState);
        return avgRate;
    }

    /// @notice Returns the current interest rate per second based on pool utilization
    /// @return The current interest rate per second in WAD (18 decimal precision)
    function interestRate() public view returns (uint128) {
        uint128 avgRate = riskEngine().interestRate(_poolUtilizationWadView(), s_marketState);
        return avgRate;
    }

    /// @notice Returns the interest rate per second based on pool utilization
    /// @dev uses the maximum utilization during this transaction, users to prevent flash deposits from lowering the interest rate
    /// @return The interest rate per second in 18 decimal precision
    function _updateInterestRate() internal returns (uint128) {
        (uint128 avgRate, uint256 endRateAtTarget) = riskEngine().updateInterestRate(
            _poolUtilizationWad(),
            s_marketState
        );
        s_marketState = s_marketState.updateRateAtTarget(uint40(endRateAtTarget));
        return avgRate;
    }

    /// @notice Calculates interest owed by a user based on their borrow state
    /// @dev Uses the difference between current and user's last borrow index to compute compound interest
    /// @param userState Packed state containing user's net borrows (left slot) and last borrow index (right slot)
    /// @param currentBorrowIndex The current global borrow index
    /// @return interestOwed Amount of interest the user owes, returns 0 if user is a lender or indices match
    function _getUserInterest(
        LeftRightSigned userState,
        uint256 currentBorrowIndex
    ) internal pure returns (uint128 interestOwed) {
        int128 netBorrows = userState.leftSlot();
        uint128 userBorrowIndex = uint128(userState.rightSlot());
        if (netBorrows <= 0 || userBorrowIndex == 0 || currentBorrowIndex == userBorrowIndex) {
            return 0;
        }
        // keep checked to catch currentBorrowIndex < userBorrowIndex
        interestOwed = Math
            .mulDivRoundingUp(
                uint128(netBorrows),
                currentBorrowIndex - userBorrowIndex,
                userBorrowIndex
            )
            .toUint128();
    }

    /// @notice Returns the current interest owed by a specific user in assets
    /// @param owner Address of the user to check
    /// @return The amount of interest currently owed by the user in assets
    function owedInterest(address owner) external view returns (uint128) {
        return _owedInterest(owner);
    }

    /// @notice Returns the assets and interest owed for a specific user
    /// @param owner Address of the user to check
    /// @return The amount of assets owned by the user (in token units)
    /// @return The amount of interest currently owed by the user (in token units)
    function assetsAndInterest(address owner) external view returns (uint256, uint256) {
        return (convertToAssets(balanceOf[owner]), _owedInterest(owner));
    }

    /// @notice Internal function to calculate interest owed by a user
    /// @dev Retrieves user state and current borrow index from storage
    /// @param owner Address of the user to check
    /// @return Amount of interest owed based on last compounded index
    function _owedInterest(address owner) internal view returns (uint128) {
        LeftRightSigned userState = s_interestState[owner];
        (uint128 currentBorrowIndex, , ) = _calculateCurrentInterestState(
            s_assetsInAMM,
            _interestRateView(_poolUtilizationWadView())
        );
        return _getUserInterest(userState, currentBorrowIndex);
    }

    /// @notice Calculates the current borrow index including uncompounded time
    /// @dev Simulates interest accrual up to the current block epoch
    /// @return The borrow index as if interest was compounded at current epoch
    function _calculateCurrentBorrowIndex() internal view returns (uint256) {
        (uint128 currentBorrowIndex, , ) = _calculateCurrentInterestState(
            s_assetsInAMM,
            _interestRateView(_poolUtilizationWadView())
        );
        return currentBorrowIndex;
    }

    /// @notice Previews the interest that would be owed if compounded now
    /// @dev Simulates interest accrual without modifying state
    /// @param owner Address of the user to preview interest for
    /// @return The amount of interest that would be owed if accrued at current epoch
    function previewOwedInterest(address owner) external view returns (uint128) {
        uint256 simulatedBorrowIndex = _calculateCurrentBorrowIndex();
        LeftRightSigned userState = s_interestState[owner];
        return _getUserInterest(userState, simulatedBorrowIndex);
    }

    /*//////////////////////////////////////////////////////////////
                            ACCOUNTING LOGIC
    //////////////////////////////////////////////////////////////*/

    /// @notice Get the pool utilization defined by the ratio of assets in the AMM to total assets.
    /// @dev calling this function will also store the utilization in the UTILIZATION_TRANSIENT_SLOT as DECIMALS
    /// if the current one is higher than the one already stored. This ensures that flash deposits can't lower the utilization for a single tx
    /// @return poolUtilization The pool utilization in basis points
    function _poolUtilization() internal returns (uint256 poolUtilization) {
        uint256 storedUtilization;
        bytes32 slot = UTILIZATION_TRANSIENT_SLOT;
        assembly {
            storedUtilization := tload(slot)
        }

        poolUtilization = _poolUtilizationView();

        if (storedUtilization > poolUtilization) {
            return storedUtilization;
        } else {
            assembly {
                tstore(slot, poolUtilization)
            }
            return poolUtilization;
        }
    }

    /// @notice Get the pool utilization defined by the ratio of assets in the AMM to total assets.
    /// @return poolUtilization The pool utilization in basis points
    function _poolUtilizationView() internal view returns (uint256 poolUtilization) {
        unchecked {
            return
                poolUtilization = Math.mulDivRoundingUp(
                    uint256(s_assetsInAMM) + uint256(s_marketState.unrealizedInterest()),
                    DECIMALS,
                    totalAssets()
                );
        }
    }

    /// @notice Get the pool utilization defined by the ratio of assets in the AMM to total assets.
    /// @dev calling this function will also store the utilization in the UTILIZATION_TRANSIENT_SLOT as DECIMALS
    /// if the current one is higher than the one already stored. This ensures that flash deposits can't lower the utilization for a single tx
    /// @return poolUtilization The pool utilization in basis points
    function _poolUtilizationWad() internal returns (uint256) {
        uint256 storedUtilization;
        bytes32 slot = UTILIZATION_TRANSIENT_SLOT;
        assembly {
            storedUtilization := tload(slot)
        }

        unchecked {
            // convert to WAD
            storedUtilization = (storedUtilization * WAD) / DECIMALS;
        }
        uint256 poolUtilization = _poolUtilizationWadView();

        if (storedUtilization > poolUtilization) {
            return storedUtilization;
        } else {
            // store the utilization as DECIMALS
            assembly {
                tstore(slot, div(mul(poolUtilization, DECIMALS), WAD))
            }
            return poolUtilization;
        }
    }

    /// @notice Get the pool utilization defined by the ratio of assets in the AMM to total assets.
    /// @return poolUtilization The pool utilization in WAD
    function _poolUtilizationWadView() internal view returns (uint256 poolUtilization) {
        unchecked {
            return
                Math.mulDivRoundingUp(
                    uint256(s_assetsInAMM) + uint256(s_marketState.unrealizedInterest()),
                    WAD,
                    totalAssets()
                );
        }
    }

    /*////////////////////////////////////////////////////////////////////
          LIFECYCLE OF A COLLATERAL TOKEN AND DELEGATE/REVOKE LOGIC
    ////////////////////////////////////////////////////////////////////*/

    /// @notice Increase the share balance of a user by `2^248 - 1` without updating the total supply.
    /// @dev This is controlled by the Panoptic Pool - not individual users.
    /// @dev When the user owes more interest than their balance, we reduce the delegation amount
    /// by their entire balance. This accounts for the fact that _accrueInterest will consume
    /// their real shares for interest payment, preventing the delegated virtual shares from
    /// being incorrectly used to pay interest obligations.
    /// @param delegatee The account to increase the balance of
    function delegate(address delegatee) external onlyPanopticPool {
        // Round up to match _accrueInterest's share calculation
        uint256 interestShares = previewWithdraw(_owedInterest(delegatee));
        uint256 balance = balanceOf[delegatee];

        // If user owes more interest than they have, their entire balance will be consumed
        // paying interest. Reduce delegation by this amount so virtual shares aren't used
        // for interest payment.
        uint256 balanceConsumedByInterest = interestShares > balance ? balance : 0;

        // keep checked to catch overflows
        balanceOf[delegatee] += type(uint248).max - balanceConsumedByInterest;
    }

    /// @notice Decrease the share balance of a user by `2^248 - 1` without updating the total supply.
    /// @dev This is controlled by the Panoptic Pool - not individual users.
    /// @dev If the user's balance is less than `2^248 - 1` (i.e., some phantom shares were consumed
    /// during the delegation period, e.g., by interest payments), their balance is zeroed and
    /// `_internalSupply` is increased to compensate for the phantom shares that were incorrectly
    /// deducted by `_burn` operations during the delegation period.
    /// @param delegatee The account to decrease the balance of
    function revoke(address delegatee) external onlyPanopticPool {
        uint256 balance = balanceOf[delegatee];
        if (type(uint248).max > balance) {
            // Phantom shares were consumed during delegation (e.g., burned for interest).
            // This can happen when the user owed more interest than their real balance
            // at the time delegate() was called. Zero the balance and restore
            // _internalSupply for the overcounted burn.
            balanceOf[delegatee] = 0;
            _internalSupply += type(uint248).max - balance;
        } else {
            // Normal case: user still has all phantom shares plus any real shares
            balanceOf[delegatee] = balance - type(uint248).max;
        }
    }

    /// @notice Settles liquidation bonus and returns remaining virtual shares to the protocol.
    /// @dev This function is where protocol loss is realized, if it exists.
    /// @param liquidator The account performing the liquidation of `liquidatee`
    /// @param liquidatee The liquidated account to settle
    /// @param bonus The liquidation bonus, in assets, to be paid to `liquidator`. May be negative
    function settleLiquidation(
        address liquidator,
        address liquidatee,
        int256 bonus
    ) external payable onlyPanopticPool {
        if (bonus < 0) {
            uint256 bonusAbs;

            unchecked {
                bonusAbs = uint256(-bonus);
            }
            address _poolManager = address(poolManager());

            if (_poolManager == address(0)) {
                uint256 underlyingTokenBalance = ERC20Minimal(underlyingToken()).balanceOf(
                    liquidator
                );
                if (underlyingTokenBalance < bonusAbs)
                    revert Errors.NotEnoughTokens(
                        underlyingToken(),
                        bonusAbs,
                        underlyingTokenBalance
                    );
                SafeTransferLib.safeTransferFrom(
                    underlyingToken(),
                    liquidator,
                    msg.sender,
                    bonusAbs
                );
            }
            _mint(liquidatee, convertToShares(bonusAbs));

            s_depositedAssets += uint128(bonusAbs);

            uint256 liquidateeBalance = balanceOf[liquidatee];

            if (type(uint248).max > liquidateeBalance) {
                balanceOf[liquidatee] = 0;
                // keep checked to catch under/overflows
                _internalSupply += type(uint248).max - liquidateeBalance;
            } else {
                // keep checked to catch under/overflows
                balanceOf[liquidatee] = liquidateeBalance - type(uint248).max;
            }
            if (_poolManager != address(0)) {
                _settleCurrencyDelta(liquidator, int256(bonusAbs));
            }
        } else {
            uint256 liquidateeBalance = balanceOf[liquidatee];

            if (type(uint248).max > liquidateeBalance) {
                // keep checked to catch under/overflows
                _internalSupply += type(uint248).max - liquidateeBalance;
                liquidateeBalance = 0;
            } else {
                // keep checked to catch under/overflows
                liquidateeBalance -= type(uint248).max;
            }
            balanceOf[liquidatee] = liquidateeBalance;

            uint256 bonusShares = convertToShares(uint256(bonus));

            // if requested amount is larger than user balance, transfer their balance and mint the remaining shares
            if (bonusShares > liquidateeBalance) {
                _transferFrom(liquidatee, liquidator, liquidateeBalance);

                // this is paying out protocol loss, so correct for that in the amount of shares to be minted
                // X: total assets in vault
                // Y: total supply of shares
                // Z: desired value (assets) of shares to be minted
                // N: total shares corresponding to Z
                // T: transferred shares from liquidatee which are a component of N but do not contribute toward protocol loss
                // Z = N * X / (Y + N - T)
                // Z * (Y + N - T) = N * X
                // ZY + ZN - ZT = NX
                // ZY - ZT = N(X - Z)
                // N = (ZY - ZT) / (X - Z)
                // N = Z(Y - T) / (X - Z)
                // subtract delegatee balance from N since it was already transferred to the delegator
                uint256 _totalSupply = totalSupply();

                // keep checked to catch any casting/math errors
                _mint(
                    liquidator,
                    Math.min(
                        Math.mulDivCapped(
                            uint256(bonus),
                            _totalSupply - liquidateeBalance,
                            uint256(Math.max(1, int256(totalAssets()) - bonus))
                        ) - liquidateeBalance,
                        _totalSupply * DECIMALS
                    )
                );
            } else {
                _transferFrom(liquidatee, liquidator, bonusShares);
            }

            // refund liquidator if they attached value expecting to settle a negative bonus in the native currency
            if (msg.value > 0) SafeTransferLib.safeTransferETH(liquidator, msg.value);
        }
    }

    /// @notice Refunds tokens to `refunder` from `refundee`.
    /// @dev Assumes that the refunder has enough money to pay for the refund.
    /// @param refunder The account refunding tokens to `refundee`
    /// @param refundee The account being refunded to
    /// @param assets The amount of assets to refund. Positive means a transfer from refunder to refundee, vice versa for negative
    function refund(address refunder, address refundee, int256 assets) external onlyPanopticPool {
        if (assets > 0) {
            _transferFrom(refunder, refundee, convertToShares(uint256(assets)));
        } else {
            uint256 sharesToTransfer = convertToShares(uint256(-assets));
            if (balanceOf[refundee] < sharesToTransfer)
                revert Errors.NotEnoughTokens(
                    address(this),
                    uint256(-assets),
                    convertToAssets(balanceOf[refundee])
                );
            _transferFrom(refundee, refunder, sharesToTransfer);
        }
    }

    /*//////////////////////////////////////////////////////////////
                     OPTION EXERCISE AND COMMISSION
    //////////////////////////////////////////////////////////////*/

    /// @notice Internal function to handle all balance and state updates for position creation and closing.
    /// @param isCreation A boolean flag to indicate if this is for option creation (true) or closing (false).
    /// @param optionOwner The user minting the option
    /// @param longAmount The amount of longs
    /// @param shortAmount The amount of shorts
    /// @param ammDeltaAmount The amount of tokens moved during creation of the option position
    ///
    function _updateBalancesAndSettle(
        address optionOwner,
        bool isCreation,
        int128 longAmount,
        int128 shortAmount,
        int128 ammDeltaAmount,
        int128 realizedPremium
    ) internal returns (uint32, int128, uint256, uint256) {
        _accrueInterest(optionOwner, IS_NOT_DEPOSIT);
        /// Snapshot state variables to compute the price per share
        uint256 _totalAssets = totalAssets();
        uint256 _totalSupply = totalSupply();

        int128 netBorrows;
        int256 tokenToPay;
        unchecked {
            // cannot miscast because all values are larger than 0
            netBorrows = isCreation ? shortAmount - longAmount : longAmount - shortAmount;
            tokenToPay = int256(ammDeltaAmount) - netBorrows - realizedPremium;
        }
        {
            // compute creditDelta with the snapshotted values
            uint256 creditDelta;
            if (longAmount > 0) {
                unchecked {
                    // cannot miscast because longAmount ?= 0
                    creditDelta = isCreation
                        ? Math.mulDivRoundingUp(
                            uint256(uint128(longAmount)),
                            _totalSupply,
                            _totalAssets
                        )
                        : Math.mulDiv(uint256(uint128(longAmount)), _totalSupply, _totalAssets);
                }
            }
            if (!isCreation) {
                if (creditDelta > 0) {
                    // update s_creditedShares: add long amounts == tokens moved into AMM or received when the position is closed
                    //
                    // An underflow is possible because Uniswap rounds long position DOWN when minting and UP when burning LP positions.
                    // For examples, for a long position, the amount of credited shares at MINT will be lower than the ones repaid back at BURN,
                    // which means the s_creditedShares tracker will become negative (the protocol lost ~1 asset worth of shares).
                    // Consequently, those shares must also be burnt, and we're making those shares come out of the option owner.
                    uint256 _creditedShares = s_creditedShares;
                    if (_creditedShares < creditDelta) {
                        s_creditedShares = 0;
                        // add the rounding haircut paid by the option owner at close
                        // rounding up again during conversion potentially add another `1` extra share as ceil*ceil is not idempotent
                        unchecked {
                            // can never miscast because  creditDelta > _creditedShares
                            tokenToPay += int256(
                                uint256(
                                    Math
                                        .mulDivRoundingUp(
                                            creditDelta - _creditedShares,
                                            _totalAssets,
                                            _totalSupply
                                        )
                                        .toUint128()
                                )
                            );
                        }
                    } else {
                        // keep unchecked to catch underflows
                        s_creditedShares -= creditDelta;
                    }
                }
            } else {
                if (creditDelta > 0) {
                    // update s_creditedShares: Add long amounts == tokens moved out of AMM or paid when creating credits
                    // keep unchecked to catch overflows
                    s_creditedShares += creditDelta;
                }
                // pay commission only when opening a new position, return notional value
            }
        }

        address _optionOwner = optionOwner;
        // Mint/Burn Shares
        if (tokenToPay > 0) {
            uint256 sharesToBurn = Math.mulDivRoundingUp(
                uint256(tokenToPay),
                _totalSupply,
                _totalAssets
            );

            if (balanceOf[_optionOwner] < sharesToBurn)
                revert Errors.NotEnoughTokens(
                    address(this),
                    uint256(tokenToPay),
                    convertToAssets(balanceOf[_optionOwner])
                );

            _burn(_optionOwner, sharesToBurn);
        } else if (tokenToPay < 0) {
            uint256 sharesToMint = Math.mulDiv(uint256(-tokenToPay), _totalSupply, _totalAssets);
            _mint(_optionOwner, sharesToMint);
        }

        // Update Pool Assets
        // use current available assets belonging to PLPs (updated after settlement)
        /// @dev realizedPremium is 0 for mints, so can add it here
        // keep checked to prevent under/overflow
        s_depositedAssets = uint256(
            int256(uint256(s_depositedAssets)) - ammDeltaAmount + realizedPremium
        ).toUint128();

        // Update s_assetsInAMM:
        // isCreation: Add short amounts == tokens moved into the AMM or used to create loans
        // !isCreation: remove short amounts == tokens moved out of the AMM or repaid when the position is closed
        // keep checked to catch miscast
        {
            int256 newAssetsInAmm = int256(uint256(s_assetsInAMM));
            newAssetsInAmm += isCreation ? int256(shortAmount) : -int256(shortAmount);
            s_assetsInAMM = uint256(newAssetsInAmm).toUint128();
        }

        {
            // add new netBorrows to the left slot
            s_interestState[_optionOwner] = s_interestState[_optionOwner].addToLeftSlot(netBorrows);
        }

        // get the utilization, store the current one in transient storage
        uint32 utilization = uint32(_poolUtilization());

        return (utilization, int128(tokenToPay), _totalAssets, _totalSupply);
    }

    /// @notice Take commission and settle ITM amounts on option creation.
    /// @param optionOwner The user minting the option
    /// @param longAmount The amount of longs
    /// @param shortAmount The amount of shorts
    /// @param ammDeltaAmount The amount of tokens moved during creation of the option position
    /// @param riskParameters The RiskEngine's core parameters
    /// @return utilization The final utilization of the collateral vault (in basis points)
    /// @return tokenPaid The total amount of tokens paid by the option owner (negative if tokens were received)
    function settleMint(
        address optionOwner,
        int128 longAmount,
        int128 shortAmount,
        int128 ammDeltaAmount,
        RiskParameters riskParameters
    ) external onlyPanopticPool returns (uint32, int128) {
        (
            uint32 utilization,
            int128 tokenPaid,
            uint256 _totalAssets,
            uint256 _totalSupply
        ) = _updateBalancesAndSettle(
                optionOwner,
                true, // isCreation = true
                longAmount,
                shortAmount,
                ammDeltaAmount,
                0 // realizedPremium not used
            );

        {
            uint128 commission = uint256(int256(shortAmount) + int256(longAmount)).toUint128();
            uint128 commissionFee = Math
                .mulDivRoundingUp(commission, riskParameters.notionalFee(), DECIMALS)
                .toUint128();
            uint256 sharesToBurn = Math.mulDivRoundingUp(commissionFee, _totalSupply, _totalAssets);
            if (riskParameters.feeRecipient() == 0) {
                _burn(optionOwner, sharesToBurn);
                emit CommissionPaid(optionOwner, address(0), commissionFee, 0);
            } else {
                unchecked {
                    _transferFrom(
                        optionOwner,
                        address(riskEngine()),
                        (sharesToBurn * riskParameters.protocolSplit()) / DECIMALS
                    );
                    _transferFrom(
                        optionOwner,
                        address(uint160(riskParameters.feeRecipient())),
                        (sharesToBurn * riskParameters.builderSplit()) / DECIMALS
                    );
                    emit CommissionPaid(
                        optionOwner,
                        address(uint160(riskParameters.feeRecipient())),
                        uint128((commissionFee * riskParameters.protocolSplit()) / DECIMALS),
                        uint128((commissionFee * riskParameters.protocolSplit()) / DECIMALS)
                    );
                }
            }
        }

        return (utilization, tokenPaid);
    }

    /// @notice Exercise an option and pay to the seller what is owed from the buyer.
    /// @dev Called when a position is burnt because it may need to be exercised.
    /// @param optionOwner The owner of the option being burned
    /// @param longAmount The notional value of the long legs of the position (if any)
    /// @param shortAmount The notional value of the short legs of the position (if any)
    /// @param ammDeltaAmount The amount of tokens moved during the option close
    /// @param realizedPremium Premium to settle on the current positions
    /// @param riskParameters The RiskEngine's core risk parameters
    /// @return The amount of tokens paid when closing that position
    function settleBurn(
        address optionOwner,
        int128 longAmount,
        int128 shortAmount,
        int128 ammDeltaAmount,
        int128 realizedPremium,
        RiskParameters riskParameters
    ) external onlyPanopticPool returns (int128) {
        (, int128 tokenPaid, uint256 _totalAssets, uint256 _totalSupply) = _updateBalancesAndSettle(
            optionOwner,
            false, // isCreation = false
            longAmount,
            shortAmount,
            ammDeltaAmount,
            realizedPremium
        );

        if (realizedPremium != 0) {
            uint128 commissionFee;
            // compute the minimum of the notionalFee and the premiumFee
            {
                uint128 commissionP;
                unchecked {
                    commissionP = realizedPremium > 0
                        ? uint128(realizedPremium)
                        : uint128(-realizedPremium);
                }
                uint128 commissionFeeP = Math
                    .mulDivRoundingUp(commissionP, riskParameters.premiumFee(), DECIMALS)
                    .toUint128();
                uint128 commissionN = uint256(int256(shortAmount) + int256(longAmount)).toUint128();
                uint128 commissionFeeN;
                unchecked {
                    commissionFeeN = Math
                        .mulDivRoundingUp(commissionN, 10 * riskParameters.notionalFee(), DECIMALS)
                        .toUint128();
                }
                commissionFee = Math.min(commissionFeeP, commissionFeeN).toUint128();
            }

            uint256 sharesToBurn = Math.mulDivRoundingUp(commissionFee, _totalSupply, _totalAssets);

            if (riskParameters.feeRecipient() == 0) {
                _burn(optionOwner, sharesToBurn);
                emit CommissionPaid(optionOwner, address(0), commissionFee, 0);
            } else {
                unchecked {
                    _transferFrom(
                        optionOwner,
                        address(riskEngine()),
                        (sharesToBurn * riskParameters.protocolSplit()) / DECIMALS
                    );
                    _transferFrom(
                        optionOwner,
                        address(uint160(riskParameters.feeRecipient())),
                        (sharesToBurn * riskParameters.builderSplit()) / DECIMALS
                    );
                    emit CommissionPaid(
                        optionOwner,
                        address(uint160(riskParameters.feeRecipient())),
                        uint128((commissionFee * riskParameters.protocolSplit()) / DECIMALS),
                        uint128((commissionFee * riskParameters.protocolSplit()) / DECIMALS)
                    );
                }
            }
        }

        return tokenPaid;
    }
}
